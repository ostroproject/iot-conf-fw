package connmanupd

import (
	"fmt"
	"os"
	"bytes"
	"io/ioutil"
)

type WifiServiceFile struct {
	Name string
	Tether bool
	IPv4 IP4
	Security Security
}


func (sf WifiServiceFile) String() string {
	const format = `
   Name     %v
   Tether   %v
   IPv4     %v
   Security %s%s
`
	pwd := ""
	if sf.Security.Mode == "wep" || sf.Security.Mode == "psk" {
		pwd = fmt.Sprintf(" (passphrase '%s')", sf.Security.Passphrase)
	}
	return fmt.Sprintf(format, sf.Name, sf.Tether, sf.IPv4,
		sf.Security.Mode, pwd)
}


const (
	wiredServiceFileFmt = `# Generated by connmanupd. Do not edit!
[global]
Name=%s
Description=Wired LAN Network

[service_ethernet]
Type=ethernet
IPv4=%v
IPv6=%v
AutoConnect=%v
`
	wiredServiceFilePath = "%s/wired.config"
	
	wifiServiceFileFmt = `# Generated by connmanupd. Do not edit!
[global]
Name=WiFi
Description=Wireless LAN Network

[service_wifi_%s]
Type=wifi
Name=%s
IPv4=%v
IPv6=%v
Security=%v
AutoConnect=%v
Hidden=%v
`
	wifiServiceFilePath = "%s/wifi.config"
)


func (c *Conf) removeWiredServiceFile(dir string) error {
	if c.Wired.Valid {
		path := fmt.Sprintf(wiredServiceFilePath, dir)
		
		if err := os.Remove(path); err != nil {
			if !os.IsNotExist(err) {
				return err
			}
		}
	}

	return nil
}

func (c *Conf) writeWiredServiceFile(dir string) error {
	e := c.Wired
	
	if !e.Valid {
		return nil
	}

	if e.Enable {
		path := fmt.Sprintf(wiredServiceFilePath, dir)
		
		file, oerr := os.OpenFile(path, os.O_RDWR | os.O_CREATE | os.O_TRUNC, 0644)
		if oerr != nil {
			return oerr
		}

		defer func () {
			file.Close()
		}()
		
		ac := false
		if e.Connect == "auto" {
			ac = true
		}
		buf := []byte(fmt.Sprintf(wiredServiceFileFmt, e.Name,
			e.IPv4, "off", ac))

		count, werr := file.Write(buf)		
		if werr != nil {
			return werr
		}
		if count != len(buf) {
			return fmt.Errorf("Failed to create/update '%s': partial write (requested %d byte, wrote %d)\n",
				path, len(buf), count)
		}
	}

	return nil
}

func (c *Conf) removeWiFiServiceFile(dir string) error {
	if c.WiFi.Valid {
		path := fmt.Sprintf(wifiServiceFilePath, dir)
		
		if err := os.Remove(path); err != nil {
			if !os.IsNotExist(err) {
				return err
			}
		}
	}

	return nil
}

func (c *Conf) writeWiFiServiceFile(dir string) error {
	w := c.WiFi
	
	if !w.Valid {
		return nil
	}

	if w.Enable && !w.Tether {
		path := fmt.Sprintf(wifiServiceFilePath, dir)
		
		file, oerr := os.OpenFile(path, os.O_RDWR | os.O_CREATE | os.O_TRUNC, 0644)
		if oerr != nil {
			return oerr
		}

		defer func () {
			file.Close()
		}()
		
		ac := false
		if w.Connect == "auto" {
			ac = true
		}
		buf := []byte(fmt.Sprintf(wifiServiceFileFmt, w.Name, w.Name,
			w.IPv4, "off", w.Security, ac, w.Hidden))

		count, werr := file.Write(buf)		
		if werr != nil {
			return werr
		}
		if count != len(buf) {
			return fmt.Errorf("Failed to create/update '%s': partial write (requested %d byte, wrote %d)\n",
				path, len(buf), count)
		}
	}

	return nil
}

func (c *Conf) readWiFiServiceFile(dir string) *WifiServiceFile {
	sf := &WifiServiceFile{"", true, IP4{"","","",""}, Security{"",""}}
	path := fmt.Sprintf(wifiServiceFilePath, dir)
		
	file, oerr := os.OpenFile(path, os.O_RDONLY, 0644)
	if oerr != nil {
		return sf
	}

	sf.Tether = false

	content, rerr := ioutil.ReadAll(file)
	file.Close()
	if rerr != nil {
		return sf
	}
	
	lines := bytes.Split(content, []byte("\n"))
	wifiSection := false

	for _, line := range lines {
		l := bytes.Trim(line, " \t\f")
		lgh := len(l)

		if lgh < 1 {
			continue
		}
		
		if lgh > 2 && l[0] == byte('[') && l[lgh-1] == byte(']') {
			sec := bytes.Trim(l[1:lgh-2], " \t\f")
			wifiSection = (len(sec) > 13 && bytes.Equal(sec[0:13], []byte("service_wifi_")))
			continue
		}

		if !wifiSection {
			continue
		}

		kv := bytes.Split(l, []byte("="))
		if len(kv) != 2 {
			continue
		}
		
		switch val := bytes.Trim(kv[1], " \t"); string(bytes.Trim(kv[0], " \t")) {
		case "Name":
			sf.Name = string(val)
		case "Tether":
			sf.Tether = bytes.Equal(val, []byte("true"))
		case "IPv4":
			ip := bytes.Split(val, []byte("/"))
			switch len(ip) {
			case 1:
				sf.IPv4.Method = string(val)
			case 3:
				sf.IPv4.Method = "manual"
				sf.IPv4.Address = string(ip[0])
				sf.IPv4.Netmask = string(ip[1])
				sf.IPv4.Gateway = string(ip[2])
			}
		case "Security":
			sf.Security.Mode = string(val)
		case "Passphrase":
			sf.Security.Passphrase = string(val)
		}
	}

	return sf
}
